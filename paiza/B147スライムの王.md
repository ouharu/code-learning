# 暴力思路

1. 将数组进行降序排列
2. 当X<max时
    1. 找出数组中第一个不小于X的数值，加入X，合并次数加1，数组中pop出该数值
        - 
    2. 判断X<max，符合条件，再次执行上步操作
    3. 若出现X<num，说明X无法合并变大，返回-1
3. 返回合并次数

```python
N,X = map(int,input().split())

nums = list(map(int,input().split()))
# 从大到小排列，提高合并效率
nums.sort(reverse=True)


def find_slime_king(N:int,X:int,nums:list) -> int:
    count = 0
    max = nums[0]
    # 二分查找可改善查找nums中最接近X的元素
    while X <= max:
        for i,num in enumerate(nums):
            if X >= num:
                X += num
                count += 1
                nums.pop(i)
                break
        else:
            # X小于num，无法合并
            return -1

    return count

print(find_slime_king(N,X,nums))
```

# 二分查找实现

```python
xxx
```



# 练习实现binary search in leetcode

> labuladong algorithm：https://labuladong.online/algo/essential-technique/binary-search-framework/#%E4%B8%80%E3%80%81%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0-%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2



leetcode 704

## 循环



## 递归



# 左右边界问题